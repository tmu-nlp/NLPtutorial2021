# -*- coding: utf-8 -*-
"""Untitled3.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1N5VTrFTy3-pVgvZEDm_rR8jTeonkitJ_
"""

!git clone https://github.com/neubig/nlptutorial.git

import math
from tqdm import tqdm_notebook as tqdm
from collections import defaultdict
class sr_parser():
  def __init__(self):
    self.w = [defaultdict(int), defaultdict(int), defaultdict(int)]

  def MakeFeats(self, stack, queue):
    feats = defaultdict(int)
    if len(stack) > 0 and len(queue) > 0:
      feats["W-1"+stack[-1][1]+"W-0"+queue[0][1]] += 1
      feats["W-1"+stack[-1][1]+"P-0"+queue[0][2]] += 1
      feats["P-1"+stack[-1][2]+"W-0"+queue[0][1]] += 1
      feats["P-1"+stack[-1][2]+"P-0"+queue[0][2]] += 1
    if len(stack) > 1:
      feats["W-2"+stack[-2][1]+"W-1"+stack[-1][1]] += 1
      feats["W-2"+stack[-2][1]+"P-1"+stack[-1][2]] += 1
      feats["P-2"+stack[-2][2]+"W-1"+stack[-1][1]] += 1
      feats["P-2"+stack[-2][2]+"P-1"+stack[-1][2]] += 1
    return feats  

  def ShiftReduce(self, queue):
    heads = [0]*(len(queue)+1)
    stack = [(0, "ROOT", "ROOT")]
    while len(queue) > 0 or len(stack) > 1:
      feats = self.MakeFeats(stack, queue)
      s_s, s_l, s_r = 0, 0, 0
      for key, value in feats.items():
        s_s += self.w[0][key] * value  
        s_l += self.w[1][key] * value  
        s_r += self.w[2][key] * value
      if ((s_s >= s_l and s_s >= s_r and len(queue) > 0) or len(stack) < 2):
        stack.append(queue.pop(0))
      elif s_l >= s_r:
        heads[stack[-2][0]] = stack[-1][0]
        stack.pop(-2) 
      else:
        heads[stack[-1][0]] =stack[-2][0]
        stack.pop(-1)
    return heads

  def ShiftReduceTrain(self, queue, heads):
    unproc = []
    stack = [(0, "ROOT", "ROOT")]
    for i in range(len(heads)):
      unproc.append(heads.count(i))
    while len(queue) > 0 or len(stack) > 1:
      feats = self.MakeFeats(stack, queue)
      s_s, s_l, s_r = 0, 0, 0
      for key, value in feats.items():
        s_s += self.w[0][key] * value  
        s_l += self.w[1][key] * value  
        s_r += self.w[2][key] * value 
      if (s_s >= s_l and s_s >= s_r and len(queue) > 0) or len(stack)<2:
        ans = "SHIFT"
      elif s_l >= s_r:
        ans = "LEFT"
      else:
        ans = "RIGHT"
      if len(stack) < 2:
        corr = "SHIFT"
        stack.append(queue.pop(0))
      if heads[stack[-1][0]] == stack[-2][0] and unproc[stack[-1][0]] == 0:
        corr = "RIGHT"
        unproc[stack[-2][0]] -= 1
        stack.pop(-1)
      elif heads[stack[-2][0]]== stack[-1][0] and unproc[stack[-2][0]] == 0:
        corr = "LEFT"
        unproc[stack[-1][0]] -= 1
        stack.pop(-2)
      else:
        corr = "SHIFT"
        stack.append(queue.pop(0))
      if ans != corr:
        for key, value in feats.items():
          if ans == "SHIFT":
            self.w[0][key] -= value
          elif ans == "LEFT":
            self.w[1][key] -= value
          else:
            self.w[2][key] -= value
          
          if corr == "SHIFT":
            self.w[0][key] += value
          elif corr == "LEFT":
            self.w[1][key] += value
          else:
            self.w[2][key] += value

  def train_sr(self, file_name, epoch):
    for iteration in tqdm(range(epoch)):
      with open(file_name, encoding="utf-8") as f:
        queue_heads = []
        queue = []
        heads = [-1]
        for line in f:
          line = line.strip().split('\t')
          if len(line)>1:
            queue.append((int(line[0]), line[1], line[3]))
            heads.append(int(line[6]))
          else:
            queue_heads.append([queue, heads])
            queue = []
            heads = [-1]
      for queue, heads in queue_heads:
        self.ShiftReduceTrain(queue, heads)

  def test_sr(self, file_name):
    with open(file_name, encoding="utf-8") as f, open('/content/myanswer.txt', 'w', encoding="utf-8") as g:
      queue_ls = []
      queue = []
      for line in f:
        line = line.strip().split('\t')
        if len(line)>1:
          queue.append((int(line[0]), line[1], line[3]))
        else:
          queue_ls.append(queue)
          queue = []
      for queue in queue_ls:
        heads = self.ShiftReduce(queue)
        heads.pop(0)
        for i in range(len(heads)):
          g.write(f'{i}\t_\t_\t_\t_\t_\t{heads[i]}\t_\n')
        g.write('\n')

#演習問題
train_input = "/content/nlptutorial/data/mstparser-en-train.dep"
test_input = "/content/nlptutorial/data/mstparser-en-test.dep"
sr = sr_parser()
sr.train_sr(train_input, 30)
sr.test_sr(test_input)
#66.738521% (3096/4639)