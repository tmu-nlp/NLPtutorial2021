# -*- coding: utf-8 -*-
"""Untitled3.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1N5VTrFTy3-pVgvZEDm_rR8jTeonkitJ_
"""

!git clone https://github.com/neubig/nlptutorial.git

import numpy as np
from tqdm import tqdm
from collections import defaultdict

class RNN():
  def __init__(self, node):
    self.node = node
    self.x_ids = defaultdict(lambda: len(self.x_ids))
    self.y_ids = defaultdict(lambda: len(self.y_ids))
    self.feat_lab = []
    np.random.seed(2021)
  
  def find_best(self, p):
    y = 0
    for i in range(len(p)):
      if p[i] > p[y]:
        y = i
    return y

  def create_one_hot(self, id, size):
    vec = np.zeros(size)
    vec[id] = 1
    return vec

  def softmax(self, x):
    tmp = np.sum(np.exp(x))
    return np.exp(x)/tmp

  def create_id_net(self, data_name):
    with open(data_name, encoding="utf-8") as f:
      for line in f:
        words = line.strip().split(" ")
        for word in words:
          x, y = word.split("_")
          self.x_ids[x]
          self.y_ids[y]
    with open(data_name, encoding="utf-8") as f:
      for line in f:
        ones = []
        words = line.strip().split(" ")
        for word in words:
          x, y = word.split("_")
          x_one = self.create_one_hot(self.x_ids[x], len(self.x_ids))
          y_one = self.create_one_hot(self.y_ids[y], len(self.y_ids))
          ones.append([x_one, y_one])
        self.feat_lab.append(ones)
      self.w_rx = np.random.rand(self.node, len(self.x_ids))/5 - 0.1
      self.w_rh = np.random.rand(self.node, self.node)/5 - 0.1
      self.b_r = np.random.rand(self.node)/5 - 0.1
      self.w_oh = np.random.rand(len(self.y_ids), self.node)/5 - 0.1
      self.b_o = np.random.rand(len(self.y_ids))/5 - 0.1
                              
  def forward_rnn(self, line):
    h = []
    p = []
    y = []
    for t in range(len(line)):
      x, yd = line[t]
      if t > 0:
        h.append(np.tanh(np.dot(self.w_rx, x) + np.dot(self.w_rh, h[t-1]) + self.b_r))
      else:
        h.append(np.tanh(np.dot(self.w_rx, x) + self.b_r))
      p.append(self.softmax(np.dot(self.w_oh, h[t]) + self.b_o))
      y.append(self.find_best(p[t]))
    return h, p, y

  def gradient_rnn(self, line, p, h):
    delta_w_rx = np.zeros((self.node, len(self.x_ids)))
    delta_w_rh = np.zeros((self.node, self.node))
    delta_b_r = np.zeros(self.node)
    delta_w_oh = np.zeros((len(self.y_ids), self.node))
    delta_b_o = np.zeros(len(self.y_ids))
    delta_r_d = np.zeros(self.node)
    for t in reversed(range(len(line))):
      x, yd = line[t]
      delta_o_d = yd - p[t]
      delta_w_oh += np.outer(delta_o_d, h[t])
      delta_b_o += delta_o_d
      delta_r = np.dot(delta_r_d, self.w_rh) + np.dot(delta_o_d, self.w_oh)
      delta_r_d = delta_r*(1 - h[t]**2)
      delta_w_rx += np.outer(delta_r_d, x)
      delta_b_r += delta_r_d
      if t != 0:
        delta_w_rh += np.outer(delta_r_d, h[t-1])
    return [delta_w_rx, delta_w_rh, delta_b_r, delta_w_oh, delta_b_o]

  def update_weights(self, delta, lambd):
    delta_w_rx, delta_w_rh, delta_b_r, delta_w_oh, delta_b_o = delta
    self.w_rx += lambd * delta_w_rx
    self.w_rh += lambd * delta_w_rh
    self.b_r += lambd * delta_b_r
    self.w_oh += lambd * delta_w_oh
    self.b_o += lambd * delta_b_o

  def train_RNN(self, data, lambd, iteration):
    self.create_id_net(data)
    for i in tqdm(range(iteration)):
      for line in self.feat_lab:
        h, p, y = self.forward_rnn(line)
        delta = self.gradient_rnn(line, p, h)
        self.update_weights(delta, lambd)

  def create_features(self, x):
    phi = []
    words=x.strip().split(" ")
    for word in words:
      if word in self.x_ids:
        phi.append(self.create_one_hot(self.x_ids[word], len(self.x_ids)))
      else:
        phi.append(np.zeros(len(self.x_ids)))
    return phi

  def test_forward_rnn(self, line):
    h = []
    p = []
    y = []
    for t in range(len(line)):
      x = line[t]
      if t > 0:
        h.append(np.tanh(np.dot(self.w_rx, x) + np.dot(self.w_rh, h[t-1]) + self.b_r))
      else:
        h.append(np.tanh(np.dot(self.w_rx, x) + self.b_r))
      p.append(self.softmax(np.dot(self.w_oh, h[t]) + self.b_o))
      y.append(self.find_best(p[t]))
    return h, p, y

  def predict(self, data_name):
    with open(data_name, encoding="utf-8") as data, open("/content/my_answer.txt", "w", encoding="utf-8") as f:
      for line in data:
        sent = []
        phi = self.create_features(line)
        h, p, y = self.test_forward_rnn(phi)
        for ans in y:
          for value, id in self.y_ids.items():
            if id == ans:
              sent.append(value)
        f.write(" ".join(sent)+"\n")

#テスト
train_input = "/content/nlptutorial/test/05-train-input.txt"
test_input = "/content/nlptutorial/test/05-test-input.txt"
rnn = RNN(node=20)
rnn.train_RNN(train_input, 0.1 , 10)
rnn.predict(test_input)

#演習問題
train_input = "/content/nlptutorial/data/wiki-en-train.norm_pos"
test_input = "/content/nlptutorial/data/wiki-en-test.norm"
rnn = RNN(node=32)
rnn.train_RNN(train_input, 0.005 , 10)
rnn.predict(test_input)

"""node = 20, lambda = 0.005, iteration = 10
Accuracy: 86.13% (3930/4563)

Most common mistakes:
JJ --> NN       41
NN --> NNP      41
JJ --> NNP      32
VBN --> JJ      30
NNS --> NNP     26
NN --> NNS      25
NNS --> NN      22
NNP --> NN      22
NN --> JJ       15
VBN --> NN      13

node=32, lambda = 0.005, iteration = 10
Accuracy: 86.26% (3936/4563)

Most common mistakes:
JJ --> NN       51
NN --> NNP      43
JJ --> NNP      35
NNS --> NNP     28
NNS --> NN      27
NN --> NNS      23
NNP --> NN      19
VBN --> JJ      17
JJ --> NNS      16
VBN --> NN      14
"""